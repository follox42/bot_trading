""";Gestionnaire de données pour le trading en direct.;Récupère et maintient les données historiques et temps réel nécessaires aux stratégies.;S'intègre avec le downloader existant pour obtenir l'historique complet requis.;""";import os;import pandas as pd;import numpy as np;import time;import logging;import json;from datetime import datetime, timedelta;from typing import Dict, List, Tuple, Optional, Union, Any;import threading;import asyncio;from core.strategy.constructor.constructor import StrategyConstructor;from core.live.exchange.exchange_interface import ExchangeInterface;from core.live.live_config import LiveConfig, ExchangeType;logging.basicConfig(level=logging.INFO);logger = logging.getLogger("live_data_manager");class LiveDataManager:;""";Gestionnaire de données pour le trading en direct.;Récupère et maintient les données historiques et temps réel.;""";def __init__(;self,;exchange: ExchangeInterface,;config: LiveConfig,;strategy: StrategyConstructor,;data_dir: str = "data/live";):;""";Initialise le gestionnaire de données.;Args:;exchange: Interface de l'exchange;config: Configuration du trading en direct;strategy: Constructeur de stratégie;data_dir: Répertoire pour stocker les données;""";self.exchange = exchange;self.config = config;self.strategy = strategy;self.data_dir = data_dir;os.makedirs(data_dir, exist_ok=True);self.historical_data = None;self.latest_kline = None;self.indicators_data = None;self.last_update_time = None;self.required_indicators = self._extract_required_indicators();self.update_thread = None;self.is_running = False;self._lock = threading.Lock();def _extract_required_indicators(self) -> Dict[str, int]:;""";Extrait les indicateurs requis par la stratégie et leurs périodes.;Returns:;Dict[str, int]: Dictionnaire des indicateurs et leurs périodes;""";required_indicators = {};for name, indicator in self.strategy.config.indicators_manager.list_indicators().items():;period = getattr(indicator.params, 'period', 0);if hasattr(indicator.params, 'slow_period'):;period = max(period, getattr(indicator.params, 'slow_period', 0));required_indicators[name] = period;return required_indicators;def get_required_lookback(self) -> int:;""";Calcule le nombre de points de données nécessaires pour les indicateurs.;Returns:;int: Nombre de points de données requis;""";max_period = 100;if self.required_indicators:;max_period = max(self.required_indicators.values(), default=max_period);return max(max_period * 3, 500);def _calculate_start_time(self, lookback_days: int = None) -> int:;""";Calcule le timestamp de début pour la récupération des données.;Args:;lookback_days: Nombre de jours à remonter (si None, utilise la config);Returns:;int: Timestamp de début en millisecondes;""";if lookback_days is None:;lookback_days = self.config.data_lookback_days;start_time = datetime.now() - timedelta(days=lookback_days);return int(start_time.timestamp() * 1000);async def initialize_data(self) -> pd.DataFrame:;""";Initialise les données historiques pour la stratégie.;Returns:;pd.DataFrame: Données historiques avec indicateurs;""";logger.info(f"Initialisation des données pour {self.config.market.symbol} sur {self.config.exchange.value}");required_points = self.get_required_lookback();try:;historical_data = await self._load_historical_data(required_points);if historical_data is None or len(historical_data) < 10:;raise ValueError(f"Données historiques insuffisantes pour {self.config.market.symbol}");logger.info(f"Données historiques chargées: {len(historical_data)} points");data_with_indicators = self.strategy.indicators_calculator.calculate_indicators(historical_data);self.historical_data = data_with_indicators;self.last_update_time = datetime.now();self._save_data(data_with_indicators, "initial_data.csv");return data_with_indicators;except Exception as e:;logger.error(f"Erreur lors de l'initialisation des données: {str(e)}");raise;async def initialize_with_dataframe(self, dataframe: pd.DataFrame) -> pd.DataFrame:;""";Initialise les données historiques avec un DataFrame préchargé.;Args:;dataframe: DataFrame préchargé;Returns:;pd.DataFrame: Données avec indicateurs;""";logger.info(f"Initialisation des données pour {self.config.market.symbol} avec DataFrame préchargé");try:;required_columns = ['timestamp', 'open', 'high', 'low', 'close'];missing_columns = [col for col in required_columns if col not in dataframe.columns];if missing_columns:;logger.warning(f"Colonnes manquantes dans le DataFrame: {missing_columns}");if 'timestamp' not in dataframe.columns and dataframe.index.name == 'timestamp':;dataframe = dataframe.reset_index();if any(col.lower() in dataframe.columns for col in missing_columns):;dataframe.columns = [col.lower() for col in dataframe.columns];missing_columns = [col for col in required_columns if col not in dataframe.columns];if missing_columns:;raise ValueError(f"Données incompatibles: colonnes {missing_columns} manquantes");if 'timestamp' in dataframe.columns:;if not pd.api.types.is_datetime64_dtype(dataframe['timestamp']):;dataframe['timestamp'] = pd.to_datetime(dataframe['timestamp']);dataframe = dataframe.set_index('timestamp').sort_index();data_with_indicators = self.strategy.indicators_calculator.calculate_indicators(dataframe);self.historical_data = data_with_indicators;self.last_update_time = datetime.now();self._save_dataframe(data_with_indicators);return data_with_indicators;except Exception as e:;logger.error(f"Erreur lors de l'initialisation avec DataFrame: {str(e)}");raise;async def _load_historical_data(self, required_points: int) -> pd.DataFrame:;""";Charge les données historiques depuis l'exchange ou le downloader.;Args:;required_points: Nombre de points de données requis;Returns:;pd.DataFrame: Données historiques;""";try:;symbol = self.config.market.symbol;interval = self.config.market.timeframe;if required_points > 1000:;lookback_days = max(30, self.config.data_lookback_days);df = self.exchange.get_historical_klines(;symbol=symbol,;interval=interval,;limit=required_points,;lookback_days=lookback_days;);if len(df) < required_points * 0.9:;logger.warning(f"Données insuffisantes depuis l'API ({len(df)} < {required_points}), " +;f"tentative avec le downloader...");from data.data_manager import download_data;exchange_name = self.config.exchange.value;data = await download_data(;exchange=exchange_name,;symbol=symbol.replace('USDT', '/USDT'),;timeframe=interval,;start_date=(datetime.now() - timedelta(days=lookback_days)).strftime('%Y-%m-%d'),;end_date=datetime.now().strftime('%Y-%m-%d'););if data and hasattr(data, 'dataframe'):;df = data.dataframe;else:;logger.warning("Échec du téléchargement avec le downloader");else:;klines = await asyncio.to_thread(;self.exchange.get_klines,;symbol=symbol,;interval=interval,;limit=required_points;);if not klines:;logger.warning(f"Aucune donnée récupérée pour {symbol} {interval}");return None;df = pd.DataFrame(klines);df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms');required_columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume'];missing_columns = [col for col in required_columns if col not in df.columns];if missing_columns:;logger.error(f"Colonnes manquantes dans les données: {missing_columns}");return None;df.sort_values('timestamp', inplace=True);df.set_index('timestamp', inplace=True);return df;except Exception as e:;logger.error(f"Erreur lors du chargement des données historiques: {str(e)}");return None;async def update_data(self) -> Optional[pd.DataFrame]:;""";Met à jour les données avec les dernières informations du marché.;Returns:;Optional[pd.DataFrame]: Données mises à jour avec indicateurs;""";if self.historical_data is None:;logger.warning("Les données historiques doivent être initialisées avant de les mettre à jour");return None;try:;latest_klines = await asyncio.to_thread(;self.exchange.get_klines,;symbol=self.config.market.symbol,;interval=self.config.market.timeframe,;limit=5;);if not latest_klines:;logger.warning("Aucune nouvelle donnée récupérée lors de la mise à jour");return self.historical_data;new_data = pd.DataFrame(latest_klines);new_data['timestamp'] = pd.to_datetime(new_data['timestamp'], unit='ms');new_data.set_index('timestamp', inplace=True);merged_data = self._merge_data(self.historical_data, new_data);data_with_indicators = self.strategy.indicators_calculator.calculate_indicators(merged_data);self.historical_data = data_with_indicators;self.latest_kline = new_data.iloc[-1] if len(new_data) > 0 else None;self.last_update_time = datetime.now();self._save_data(data_with_indicators.tail(100), "latest_data.csv");return data_with_indicators;except Exception as e:;logger.error(f"Erreur lors de la mise à jour des données: {str(e)}");return self.historical_data;def _merge_data(self, historical_data: pd.DataFrame, new_data: pd.DataFrame) -> pd.DataFrame:;""";Fusionne les nouvelles données avec les données historiques.;Args:;historical_data: Données historiques;new_data: Nouvelles données;Returns:;pd.DataFrame: Données fusionnées;""";combined_data = pd.concat([historical_data, new_data]);combined_data = combined_data[~combined_data.index.duplicated(keep='last')];combined_data.sort_index(inplace=True);max_points = self.get_required_lookback() + 100;if len(combined_data) > max_points:;combined_data = combined_data.iloc[-max_points:];return combined_data;def _save_data(self, data: pd.DataFrame, filename: str) -> None:;""";Sauvegarde les données dans un fichier CSV.;Args:;data: Données à sauvegarder;filename: Nom du fichier;""";try:;symbol_dir = os.path.join(self.data_dir, self.config.market.symbol);os.makedirs(symbol_dir, exist_ok=True);filepath = os.path.join(symbol_dir, filename);data.to_csv(filepath);metadata = {;"symbol": self.config.market.symbol,;"timeframe": self.config.market.timeframe,;"exchange": self.config.exchange.value,;"last_update": datetime.now().isoformat(),;"points": len(data),;"start_date": data.index[0].strftime('%Y-%m-%d %H:%M:%S') if len(data) > 0 else None,;"end_date": data.index[-1].strftime('%Y-%m-%d %H:%M:%S') if len(data) > 0 else None;};metadata_path = os.path.join(symbol_dir, "metadata.json");with open(metadata_path, 'w', encoding='utf-8') as f:;json.dump(metadata, f, indent=4);except Exception as e:;logger.error(f"Erreur lors de la sauvegarde des données: {str(e)}");def get_current_data(self) -> pd.DataFrame:;""";Retourne les données actuelles avec indicateurs.;Returns:;pd.DataFrame: Données avec indicateurs;""";return self.historical_data if self.historical_data is not None else pd.DataFrame();def get_current_price(self) -> float:;""";Retourne le prix actuel du marché.;Returns:;float: Prix actuel;""";try:;if self.latest_kline is not None:;return float(self.latest_kline['close']);ticker = self.exchange.get_ticker(self.config.market.symbol);return float(ticker['last_price']);except Exception as e:;logger.error(f"Erreur lors de la récupération du prix actuel: {str(e)}");if self.historical_data is not None and len(self.historical_data) > 0:;return float(self.historical_data['close'].iloc[-1]);return 0.0;async def start_updating(self, interval_seconds: int = None) -> None:;""";Démarre la mise à jour périodique des données.;Args:;interval_seconds: Intervalle de mise à jour en secondes;""";if self.is_running:;logger.warning("Le processus de mise à jour est déjà en cours");return;if interval_seconds is None:;interval_seconds = self.config.update_interval_seconds;self.is_running = True;logger.info(f"Démarrage des mises à jour de données toutes les {interval_seconds} secondes");asyncio.create_task(self._update_loop(interval_seconds));async def _update_loop(self, interval_seconds: int) -> None:;""";Boucle de mise à jour périodique des données.;Args:;interval_seconds: Intervalle de mise à jour en secondes;""";while self.is_running:;try:;await self.update_data();await asyncio.sleep(interval_seconds);except Exception as e:;logger.error(f"Erreur dans la boucle de mise à jour: {str(e)}");await asyncio.sleep(interval_seconds * 2);async def stop_updating(self) -> None:;"""Arrête la mise à jour périodique des données.""";self.is_running = False;logger.info("Arrêt des mises à jour de données");def prepare_backtest_data(self, lookback_periods: int = 1000) -> pd.DataFrame:;""";Prépare les données pour un backtest sur l'historique récent.;Args:;lookback_periods: Nombre de périodes historiques à utiliser;Returns:;pd.DataFrame: Données pour le backtest;""";if self.historical_data is None or len(self.historical_data) < lookback_periods:;logger.warning("Données insuffisantes pour le backtest");return None;backtest_data = self.historical_data.iloc[-lookback_periods:];self._save_data(backtest_data, "backtest_data.csv");return backtest_data;def generate_summary(self) -> Dict[str, Any]:;""";Génère un résumé des données actuelles.;Returns:;Dict: Résumé des données;""";summary = {;"symbol": self.config.market.symbol,;"timeframe": self.config.market.timeframe,;"exchange": self.config.exchange.value,;"data_points": 0,;"start_date": None,;"end_date": None,;"current_price": 0.0,;"required_indicators": self.required_indicators,;"required_lookback": self.get_required_lookback(),;"last_update": None;};if self.historical_data is not None:;summary.update({;"data_points": len(self.historical_data),;"start_date": self.historical_data.index[0].strftime('%Y-%m-%d %H:%M:%S') if len(self.historical_data) > 0 else None,;"end_date": self.historical_data.index[-1].strftime('%Y-%m-%d %H:%M:%S') if len(self.historical_data) > 0 else None,;"current_price": self.get_current_price(),;"last_update": self.last_update_time.isoformat() if self.last_update_time else None;});return summary